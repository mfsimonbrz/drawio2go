package internals

import (
	"bytes"
	"drawio2go/models"
	"fmt"
	"os"
	"strings"
	"text/template"
)

func generateCreateTableSQLStatement(table *models.Table) string {
	var sb bytes.Buffer
	foreignFields := []*models.Field{}
	sb.WriteString(fmt.Sprintf("CREATE TABLE IF NOT EXISTS %s (", strings.ToLower(table.Name)))
	for pos, field := range table.Fields {
		if pos > 0 {
			sb.WriteString(fmt.Sprintf(", %s %s", strings.ToLower(field.Name), getDatabaseFieldType(strings.ToLower(field.Type))))
		} else {
			sb.WriteString(fmt.Sprintf("%s %s", strings.ToLower(field.Name), getDatabaseFieldType(strings.ToLower(field.Type))))
		}
		if !field.Nullable {
			sb.WriteString(" NOT NULL")
		}
		if field.Primary {
			sb.WriteString(" PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY")
		}
		if field.Foreign {
			foreignFields = append(foreignFields, field)
		}
	}

	// Assuming table name is plural, and the key fields follow the pattern: table name singular + _id
	for _, field := range foreignFields {
		foreignTableName := field.Name[0:strings.Index(field.Name, "_")]
		sb.WriteString(fmt.Sprintf(", CONSTRAINT fk_%s FOREIGN KEY (%s) REFERENCES %ss (%s) ON DELETE CASCADE", foreignTableName, field.Name, foreignTableName, field.Name))
	}

	sb.WriteString(");")

	return sb.String()
}

func GenerateSelectAllStatement(table *models.Table) string {
	return fmt.Sprintf("SELECT * FROM %s;", strings.ToLower(table.Name))
}

func GenerateSelectByIdStatement(table *models.Table) string {
	primaryField := table.GetPrimaryKeyField()
	return fmt.Sprintf("SELECT * FROM %s WHERE %s = ?;", table.Name, primaryField.Name)
}

func GenerateDeleteStatement(table *models.Table) string {
	primaryField := table.GetPrimaryKeyField()
	return fmt.Sprintf("DELETE FROM %s WHERE %s = ?;", table.Name, primaryField.Name)
}

func GenerateInsertStatement(table *models.Table) string {
	var sb bytes.Buffer
	sb.WriteString(fmt.Sprintf("INSERT INTO %s VALUES (", strings.ToLower(table.Name)))
	for pos, field := range table.Fields {
		if !field.Primary {
			if pos > 0 {
				sb.WriteString(fmt.Sprintf(", %s = ?", strings.ToLower(field.Name)))
			} else {
				sb.WriteString(fmt.Sprintf("%s = ?", strings.ToLower(field.Name)))
			}
		}
	}
	sb.WriteString(")")

	return sb.String()
}

func GenerateUpdateStatement(table *models.Table) string {
	var sb bytes.Buffer
	sb.WriteString(fmt.Sprintf("UPDATE %s SET", strings.ToLower(table.Name)))
	for pos, field := range table.Fields {
		if !field.Primary {
			if pos > 0 {
				sb.WriteString(fmt.Sprintf(", %s = ?", strings.ToLower(field.Name)))
			} else {
				sb.WriteString(fmt.Sprintf(" %s = ?", strings.ToLower(field.Name)))
			}
		} else {
			sb.WriteString(fmt.Sprintf(" WHERE %s = ?", strings.ToLower(field.Name)))
		}
	}

	return sb.String()
}

func CreateModelsFile(tables []*models.Table, filepath string) error {
	models := models.Models{HasTimeField: hasTimeField(tables), Tables: tables}
	wd, err := os.Getwd()
	if err != nil {
		return err
	}

	templateFile := wd + "/internals/templates/struct.tmpl"

	funcMap := template.FuncMap{
		"title":     title,
		"lower":     strings.ToLower,
		"normalize": normalizeFieldName,
	}

	tmpl, err := template.New("struct.tmpl").Funcs(funcMap).ParseFiles(templateFile)

	if err != nil {
		return err
	}

	outputFile, err := os.Create(fmt.Sprintf("%s/models.go", filepath))
	if err != nil {
		return err
	}

	err = tmpl.Execute(outputFile, models)
	if err != nil {
		return err
	}

	return nil
}

func CreateMainFile(filepath string) error {
	imports := []models.Map{{Key: "", Value: "database/sql"}, {Key: "", Value: "fmt"}, {Key: "", Value: "log"}, {Key: "_", Value: "github.com/lib/pq"}, {Key: "", Value: "internals"}}
	consts := []models.Map{{Key: "host", Value: "\"\""}, {Key: "port", Value: "\"\""}, {Key: "dbname", Value: "\"\""}, {Key: "username", Value: "\"\""}, {Key: "password", Value: "\"\""}}
	main := models.Main{Imports: imports, Consts: consts}

	wd, err := os.Getwd()
	if err != nil {
		return err
	}

	templateFile := wd + "/internals/templates/main.tmpl"

	tmpl, err := template.New("main.tmpl").ParseFiles(templateFile)

	if err != nil {
		return err
	}

	outputFile, err := os.Create(fmt.Sprintf("%s/main.go", filepath))
	if err != nil {
		return err
	}

	err = tmpl.Execute(outputFile, main)
	if err != nil {
		return err
	}

	return nil
}

func CreateGoModFile(moduleName string, filepath string) error {
	imports := []models.Map{
		{Key: "github.com/lib/pq", Value: "v1.10.9"},
	}
	module := models.Module{Name: moduleName, Imports: imports}
	wd, err := os.Getwd()
	if err != nil {
		return err
	}

	templateFile := wd + "/internals/templates/gomod.tmpl"

	tmpl, err := template.New("gomod.tmpl").ParseFiles(templateFile)

	if err != nil {
		return err
	}

	outputFile, err := os.Create(fmt.Sprintf("%s/go.mod", filepath))
	if err != nil {
		return err
	}

	err = tmpl.Execute(outputFile, module)
	if err != nil {
		return err
	}

	return nil
}

func CreateDBInitFile(tables []*models.Table, filepath string) error {
	wd, err := os.Getwd()
	if err != nil {
		return err
	}

	templateFile := wd + "/internals/templates/init_db.tmpl"

	funcMap := template.FuncMap{
		"sql_statement": generateCreateTableSQLStatement,
		"upper":         strings.ToUpper,
	}
	tmpl, err := template.New("init_db.tmpl").Funcs(funcMap).ParseFiles(templateFile)

	if err != nil {
		return err
	}

	outputFile, err := os.Create(fmt.Sprintf("%s/db.go", filepath))
	if err != nil {
		return err
	}
	err = tmpl.Execute(outputFile, tables)
	if err != nil {
		return err
	}

	return nil
}
