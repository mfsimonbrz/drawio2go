package internals

import (
	"bytes"
	"drawio2go/models"
	"fmt"
	"os"
	"strings"
	"text/template"
)

func generateCreateTableSQLStatement(tables []*models.Table) []string {
	var foreignKeyInfoList []*models.ForeignKeyInfo = []*models.ForeignKeyInfo{}
	var statements []string
	for _, table := range tables {
		var sb bytes.Buffer
		sb.WriteString(fmt.Sprintf("CREATE TABLE IF NOT EXISTS %s (", strings.ToLower(table.Name)))
		for pos, field := range table.Fields {
			if pos > 0 {
				sb.WriteString(fmt.Sprintf(", %s %s", strings.ToLower(field.Name), getDatabaseFieldType(strings.ToLower(field.Type))))
			} else {
				sb.WriteString(fmt.Sprintf("%s %s", strings.ToLower(field.Name), getDatabaseFieldType(strings.ToLower(field.Type))))
			}
			if !field.Nullable {
				sb.WriteString(" NOT NULL")
			}
			if field.Primary {
				sb.WriteString(" PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY")
			}
			if field.Foreign {
				foreignKeyInfo := &models.ForeignKeyInfo{OriginTableName: strings.ToLower(table.Name), OriginFieldName: strings.ToLower(field.Name), DestinationTableName: field.Name[0:strings.Index(field.Name, "_")], DestinationFieldName: "id"}
				foreignKeyInfoList = append(foreignKeyInfoList, foreignKeyInfo)
			}
		}
		sb.WriteString(");")
		statements = append(statements, sb.String())
	}

	for _, fk := range foreignKeyInfoList {
		statement := fmt.Sprintf("ALTER TABLE %s ADD CONSTRAINT fk_%s FOREIGN KEY (%s) REFERENCES %ss (%s) ON DELETE CASCADE", fk.OriginTableName, fk.DestinationTableName, fk.OriginFieldName, fk.DestinationTableName, fk.DestinationFieldName)
		statements = append(statements, statement)
	}

	return statements
}

func generateSelectAllStatement(table *models.Table) string {
	return fmt.Sprintf("SELECT * FROM %s;", strings.ToLower(table.Name))
}

func generateSelectByIdStatement(table *models.Table) string {
	primaryField := table.GetPrimaryKeyField()
	return fmt.Sprintf("SELECT * FROM %s WHERE %s = $1;", table.Name, primaryField.Name)
}

func generateDeleteStatement(table *models.Table) string {
	primaryField := table.GetPrimaryKeyField()
	return fmt.Sprintf("DELETE FROM %s WHERE %s = $1;", table.Name, primaryField.Name)
}

func generateInsertStatement(table *models.Table) string {
	var sb bytes.Buffer
	sb.WriteString(fmt.Sprintf("INSERT INTO %s (", strings.ToLower(table.Name)))
	var primaryField string
	for pos, field := range table.Fields {
		if !field.Primary {
			if pos > 0 {
				sb.WriteString(fmt.Sprintf(", %s", strings.ToLower(field.Name)))
			} else {
				sb.WriteString(strings.ToLower(field.Name))
			}
		} else {
			primaryField = strings.ToLower(field.Name)
		}

	}
	sb.WriteString(")")
	sb.WriteString(" VALUES (")

	for pos, field := range table.Fields {
		if !field.Primary {
			if pos > 0 {
				sb.WriteString(fmt.Sprintf(", $%d", pos+1))
			} else {
				sb.WriteString(fmt.Sprintf("$%d", pos+1))
			}
		}
	}
	sb.WriteString(") ")
	sb.WriteString(fmt.Sprintf("RETURNING %s", primaryField))

	return sb.String()
}

func generateUpdateStatement(table *models.Table) string {
	var sb bytes.Buffer
	sb.WriteString(fmt.Sprintf("UPDATE %s SET", strings.ToLower(table.Name)))
	idPos := 0
	for pos, field := range table.Fields {
		idPos = pos
		if !field.Primary {
			if pos > 0 {
				sb.WriteString(fmt.Sprintf(", %s = $%d", strings.ToLower(field.Name), pos+1))
			} else {
				sb.WriteString(fmt.Sprintf(" %s = $%d", strings.ToLower(field.Name), pos+1))
			}
		} else {
			sb.WriteString(fmt.Sprintf(" WHERE %s = $%d", strings.ToLower(field.Name), idPos+1))
		}
	}

	return sb.String()
}

func CreateModelsFile(tables []*models.Table, filepath string) error {
	models := models.Models{HasTimeField: hasTimeField(tables), Tables: tables}
	wd, err := os.Getwd()
	if err != nil {
		return err
	}

	templateFile := wd + "/internals/templates/struct.tmpl"

	funcMap := template.FuncMap{
		"title":     title,
		"lower":     strings.ToLower,
		"normalize": normalizeFieldName,
	}

	tmpl, err := template.New("struct.tmpl").Funcs(funcMap).ParseFiles(templateFile)

	if err != nil {
		return err
	}

	outputFile, err := os.Create(fmt.Sprintf("%s/models.go", filepath))
	if err != nil {
		return err
	}

	err = tmpl.Execute(outputFile, models)
	if err != nil {
		return err
	}

	return nil
}

func CreateMainFile(moduleName string, tables []*models.Table, filepath string) error {
	imports := []models.Map{{Key: "", Value: "database/sql"}, {Key: "", Value: "fmt"}, {Key: "", Value: "log"}, {Key: "_", Value: "github.com/lib/pq"}, {Key: "", Value: fmt.Sprintf("%s/internals/data", moduleName)}, {Key: "", Value: fmt.Sprintf("%s/internals/web", moduleName)}, {Key: "", Value: "github.com/gin-gonic/gin"}}
	consts := []models.Map{{Key: "dbHost", Value: "\"\""}, {Key: "dbPort", Value: "\"\""}, {Key: "dbName", Value: "\"\""}, {Key: "dbUserName", Value: "\"\""}, {Key: "dbPassword", Value: "\"\""}}
	main := models.Main{Imports: imports, Consts: consts, Tables: tables}

	wd, err := os.Getwd()
	if err != nil {
		return err
	}

	templateFile := wd + "/internals/templates/main.tmpl"
	funcMap := template.FuncMap{
		"title": title,
	}

	tmpl, err := template.New("main.tmpl").Funcs(funcMap).ParseFiles(templateFile)

	if err != nil {
		return err
	}

	outputFile, err := os.Create(fmt.Sprintf("%s/main.go", filepath))
	if err != nil {
		return err
	}

	err = tmpl.Execute(outputFile, main)
	if err != nil {
		return err
	}

	return nil
}

func CreateGoModFile(moduleName string, filepath string) error {
	imports := []models.Map{
		{Key: "github.com/lib/pq", Value: "v1.10.9"},
	}
	module := models.Module{Name: moduleName, Imports: imports}
	wd, err := os.Getwd()
	if err != nil {
		return err
	}

	templateFile := wd + "/internals/templates/gomod.tmpl"

	tmpl, err := template.New("gomod.tmpl").ParseFiles(templateFile)

	if err != nil {
		return err
	}

	outputFile, err := os.Create(fmt.Sprintf("%s/go.mod", filepath))
	if err != nil {
		return err
	}

	err = tmpl.Execute(outputFile, module)
	if err != nil {
		return err
	}

	return nil
}

func CreateDBInitFile(tables []*models.Table, filepath string) error {
	wd, err := os.Getwd()
	if err != nil {
		return err
	}

	templateFile := wd + "/internals/templates/init_db.tmpl"

	tmpl, err := template.New("init_db.tmpl").ParseFiles(templateFile)

	if err != nil {
		return err
	}

	outputFile, err := os.Create(fmt.Sprintf("%s/db.go", filepath))
	if err != nil {
		return err
	}
	statements := generateCreateTableSQLStatement(tables)
	err = tmpl.Execute(outputFile, statements)
	if err != nil {
		return err
	}

	return nil
}

func CreateDataFiles(moduleName string, tables []*models.Table, filepath string) error {
	wd, err := os.Getwd()
	if err != nil {
		return err
	}

	templateFile := wd + "/internals/templates/data.tmpl"
	funcMap := template.FuncMap{
		"insert":    generateInsertStatement,
		"get":       generateSelectAllStatement,
		"getById":   generateSelectByIdStatement,
		"delete":    generateDeleteStatement,
		"update":    generateUpdateStatement,
		"title":     title,
		"normalize": normalizeFieldName,
		"minus":     minus,
	}
	tmpl, err := template.New("data.tmpl").Funcs(funcMap).ParseFiles(templateFile)
	if err != nil {
		return err
	}

	for _, table := range tables {
		outputFile, err := os.Create(fmt.Sprintf("%s/%s.go", filepath, table.Name))
		if err != nil {
			return err
		}
		dataInfo := &models.DataInfo{ModuleName: moduleName, Table: table}
		err = tmpl.Execute(outputFile, dataInfo)
		if err != nil {
			return err
		}
	}

	return nil
}

func CreateWebFiles(moduleName string, tables []*models.Table, filepath string) error {
	wd, err := os.Getwd()
	if err != nil {
		return err
	}

	templateFile := wd + "/internals/templates/web.tmpl"
	funcMap := template.FuncMap{
		"title": title,
	}
	tmpl, err := template.New("web.tmpl").Funcs(funcMap).ParseFiles(templateFile)
	if err != nil {
		return err
	}

	for _, table := range tables {
		outputFile, err := os.Create(fmt.Sprintf("%s/%s.go", filepath, table.Name))
		if err != nil {
			return err
		}
		dataInfo := &models.DataInfo{ModuleName: moduleName, Table: table}
		err = tmpl.Execute(outputFile, dataInfo)
		if err != nil {
			return err
		}
	}

	return nil
}
